Two significant suggestions and some small ones.

### `Quest`: Pack `uuid` and `timestamp`

Throughout the codebase, `string` UUIDs are used as identifiers for Quests. Based on the Rabbithole docs, it looks like these are probably standard RFC4122 UUIDs, like those generated by the NPM [`uuid`](https://www.npmjs.com/package/uuid) package.

The canonical string representation of a UUID is a 36 character string with 5 groups of hex digits separated by hyphens:

```
"07ad2ced-d813-4b14-9679-5389d38f7a5e"
```

UUIDs are serialized as strings (and often stored as strings when storage efficiency doesn't matter much), but they are just 128-bit numbers that can be much more efficiently stored as bytes.

Storing an off chain UUID as a Solidity `string` requires writing to three storage slots:
- Slot 1: The string's length, mostly empty.
- Slot 2: The first 32 characters of the string.
- Slot 3: The remaining 4 characters, mostly empty.

This is expensive to read and write! Passing these as arguments and reading and writing them from storage will use a lot more gas than necessary.

A UUID can instead be stored as 16 bytes instead of 36, using its underlying numeric value. For example, the UUID above can be stored as:

```
bytes16(0x07ad2cedd8134b1496795389d38f7a5e)
```

(Or even as a `uint128`). This is exactly half a storage slot, leaving plenty of room to pack it with other data, like another `bytes16` or `uint128`.

You'll save gas by using `bytes16` or `uint128` throughout the codebase, but the most significant savings are in `RabbitHoleReceipt`, which includes two mappings indexed by token ID:

```solidity
    // storage
    mapping(uint => string) public questIdForTokenId;
    address public royaltyRecipient;
    address public minterAddress;
    uint public royaltyFee;
    mapping(uint => uint) public timestampForTokenId;
    ReceiptRenderer public ReceiptRendererContract;
    IQuestFactory public QuestFactoryContract;
```

You can instead pack the `timestamp` and `questId` for each token ID together in a struct that fits in a single storage slot:

```solidity
    struct TokenData {
        bytes16 questId;
        uint128 timestamp;
    }

    // storage
    mapping(uint => TokenData) public tokenData;
    address public royaltyRecipient;
    address public minterAddress;
    uint public royaltyFee;
    ReceiptRenderer public ReceiptRendererContract;
    IQuestFactory public QuestFactoryContract;
```

You'll need to update `mint` to store the struct and cast `block.timestamp` to a `uint128`. (This is fine: `block.timestamp` won't overflow a `uint32` until the year 2106, so there is plenty of room in a `uint128`).

```solidity
    function mint(address to_, bytes16 questId_) public onlyMinter {
        _tokenIds.increment();
        uint newTokenID = _tokenIds.current();
        tokenData[newTokenID] = TokenData({
            questId: questId_,
            timestamp: uint128(block.timestamp)
        });
        _safeMint(to_, newTokenID);
    }
```

You can now skip the hash comparisons in `getOwnedTokenIdsOfQuest`:

```solidity
    function getOwnedTokenIdsOfQuest(
        bytes16 questId_,
        address claimingAddress_
    ) public view returns (uint[] memory) {
        uint msgSenderBalance = balanceOf(claimingAddress_);
        uint[] memory tokenIdsForQuest = new uint[](msgSenderBalance);
        uint foundTokens = 0;

        for (uint i = 0; i < msgSenderBalance; i++) {
            uint tokenId = tokenOfOwnerByIndex(claimingAddress_, i);
            if (tokenData[tokenId].questId == questId_) {
                tokenIdsForQuest[i] = tokenId;
                foundTokens++;
            }
        }

        uint[] memory filteredTokens = new uint[](foundTokens);
        uint filterTokensIndexTracker = 0;

        for (uint i = 0; i < msgSenderBalance; i++) {
            if (tokenIdsForQuest[i] > 0) {
                filteredTokens[filterTokensIndexTracker] = tokenIdsForQuest[i];
                filterTokensIndexTracker++;
            }
        }
        return filteredTokens;
    }
```

...and read it back as a `bytes16` in `tokenURI`.

```solidity
    /// @dev return the token uri, this delegates to the receipt renderer contract
    function tokenURI(
        uint tokenId_
    ) public view virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {
        require(_exists(tokenId_), 'ERC721URIStorage: URI query for nonexistent token');
        require(QuestFactoryContract != IQuestFactory(address(0)), 'QuestFactory not set');

        bytes16 questId = tokenData[tokenId_].questId;
        (address questAddress, uint totalParticipants, ) = QuestFactoryContract.questInfo(questId);
        IQuest questContract = IQuest(questAddress);

        bool claimed = questContract.isClaimed(tokenId_);
        uint rewardAmount = questContract.getRewardAmount();
        address rewardAddress = questContract.getRewardToken();

        return ReceiptRendererContract.generateTokenURI(tokenId_, questId, totalParticipants, claimed, rewardAmount, rewardAddress);
    }
```

You get the idea: follow the compiler and replace any `string memory` token IDs with `bytes16`. (I'm happy to share a branch with this full refactor in a private repo).

I recommend encoding and decoding UUIDs offchain: represent them everywhere in the contracts as `bytes16` values. However, if you really need to parse or encode a UUID onchain, you nerdsniped me into writing an [example library](https://github.com/horsefacts/lib-uuid).

**Impact:**
- `createQuest`: ~107,000 gas
- `mintReceipt`: ~25,000 gas
- `claim`: ~1000 gas
- `QuestFactory` deployment: ~521,000 gas

Full gas report after:

```
User story gas usage -- ETH $1500, gasPrice: 100 gwei
=========================================================

Erc1155Quest
=========================================================
Start
···························
startQuest
      $4.80   (32,015) Start ERC1155 quest
      $4.80   (32,015) Start ERC1155 quest
Range: $4.80 - $4.80

Withdraw
···························
withdrawRemainingRewards
      $5.72   (38,143) Withdraw remaining rewards from ERC1155 quest
Range: $5.72 - $5.72

Erc20Quest
=========================================================
Claim
···························
claim
     $18.83  (125,560) 1st claim
Range: $18.83 - $18.83

Start
···························
startQuest
      $4.86   (32,388) Start ERC20 quest
      $4.86   (32,388) Start ERC20 quest
Range: $4.86 - $4.86

Withdraw
···························
withdrawFee
      $7.12   (47,496) Withdraw fee from ERC20 quest
Range: $7.12 - $7.12

withdrawRemainingRewards
      $8.45   (56,346) Withdraw remaining rewards from ERC20 quest
Range: $8.45 - $8.45

QuestFactory
=========================================================
Mint Receipt
···························
mintReceipt
     $39.40  (262,662) 1st mint
     $37.67  (251,162) 2st mint
Range: $37.67 - $39.40

Quest
···························
createQuest
    $187.40 (1,249,309) Create ERC1155 quest
    $187.40 (1,249,309) Create ERC1155 quest
    $211.53 (1,410,209) Create ERC20 quest
    $211.53 (1,410,209) Create ERC20 quest
Range: $187.40 - $211.53

RewardAllowlist
···························
setRewardAllowlistAddress
      $8.06   (53,760) Set the reward allowlist
      $8.06   (53,760) Set the reward allowlist
Range: $8.06 - $8.06


=========================================================
·-----------------------------------------------|---------------------------|--------------|-----------------------------·
|             Solc version: 0.8.15              ·  Optimizer enabled: true  ·  Runs: 5000  ·  Block limit: 30000000 gas  │
················································|···························|··············|······························
|  Methods                                                                                                               │
··················|·····························|·············|·············|··············|···············|··············
|  Contract       ·  Method                     ·  Min        ·  Max        ·  Avg         ·  # calls      ·  eur (avg)  │
··················|·····························|·············|·············|··············|···············|··············
|  Erc1155Quest   ·  claim                      ·          -  ·          -  ·      125560  ·            2  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  Erc1155Quest   ·  start                      ·      32015  ·      32388  ·       32202  ·            8  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  Erc1155Quest   ·  withdrawRemainingTokens    ·      38143  ·      56346  ·       47245  ·            4  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  Erc20Quest     ·  withdrawFee                ·          -  ·          -  ·       47496  ·            2  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  createQuest                ·    1249309  ·    1410209  ·     1329759  ·            8  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  mintReceipt                ·     251162  ·     262662  ·      256912  ·            4  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  setRewardAllowlistAddress  ·          -  ·          -  ·       53760  ·            4  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  SampleErc1155  ·  safeTransferFrom           ·      58436  ·      58448  ·       58442  ·            2  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  SampleERC20    ·  transfer                   ·          -  ·          -  ·       51314  ·            2  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  Deployments                                  ·                                          ·  % of limit   ·             │
················································|·············|·············|··············|···············|··············
|  QuestFactory                                 ·          -  ·          -  ·     4791755  ·         16 %  ·          -  │
················································|·············|·············|··············|···············|··············
|  RabbitHoleReceipt                            ·          -  ·          -  ·     2705996  ·          9 %  ·          -  │
················································|·············|·············|··············|···············|··············
|  ReceiptRenderer                              ·          -  ·          -  ·     1197410  ·          4 %  ·          -  │
················································|·············|·············|··············|···············|··············
|  SampleErc1155                                ·          -  ·          -  ·     1417938  ·        4.7 %  ·          -  │
················································|·············|·············|··············|···············|··············
|  SampleERC20                                  ·          -  ·          -  ·      737180  ·        2.5 %  ·          -  │
·-----------------------------------------------|-------------|-------------|--------------|---------------|-------------·
```


### `QuestFactory`: Use enum for `contractType_`

[`QuestFactory#createQuest`](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L61-L137) passes `contractType_` as a string, either `'erc20'` or `'erc1155'`, and switches by comparing its hashed value:

```solidity
    function createQuest(
        address rewardTokenAddress_,
        uint256 endTime_,
        uint256 startTime_,
        uint256 totalParticipants_,
        uint256 rewardAmountOrTokenId_,
        string memory contractType_,
        string memory questId_
    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {
        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();

        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc20'))) {
          // Details omitted - do ERC20 stuff
        }

        if (keccak256(abi.encodePacked(contractType_)) == keccak256(abi.encodePacked('erc1155'))) {
          // Details omitted — do ERC1155 stuff
        }

        revert QuestTypeInvalid();
    }
```

Consider using an enum for this argument instead. Passing an encoded string requires 3 words of calldata, but an enum (represented internally as a `uint8`) requires just one:

```bash
$ cast abi-encode "stringArg(string)" "erc20"
0x0000000000000000000000000000000000000000000000000000000000000020
  0000000000000000000000000000000000000000000000000000000000000005
  6572633230000000000000000000000000000000000000000000000000000000
$ cast abi-encode "enumArg(uint8)" 0x1
0x0000000000000000000000000000000000000000000000000000000000000001
```

Additionally, you can replace expensive `keccak256` calls with simple equality comparisons:

```solidity
    enum ContractType {
        ERC20,
        ERC1155
    }

    function createQuest(
        address rewardTokenAddress_,
        uint256 endTime_,
        uint256 startTime_,
        uint256 totalParticipants_,
        uint256 rewardAmountOrTokenId_,
        ContractType contractType_,
        string memory questId_
    ) public onlyRole(CREATE_QUEST_ROLE) returns (address) {
        if (quests[questId_].questAddress != address(0)) revert QuestIdUsed();

        if (contractType_ == ContractType.ERC20) {
          // Details omitted - do ERC20 stuff
        }

        if (contractType_ == ContractType.ERC1155) {
          // Details omitted — do ERC1155 stuff
        }

        revert QuestTypeInvalid();
    }
```

Gas impact: ~2000 gas.

```
·-----------------------------------------------|---------------------------|--------------|-----------------------------·
|             Solc version: 0.8.15              ·  Optimizer enabled: true  ·  Runs: 5000  ·  Block limit: 30000000 gas  │
················································|···························|··············|······························
|  Methods                                                                                                               │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  createQuest                ·    1365913  ·    1508398  ·     1437156  ·            8  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  createQuest - optimized    ·    1363606  ·    1506533  ·     1435070  ·            8  ·          -  │
·-----------------------------------------------|-------------|-------------|--------------|---------------|-------------·
```

### `QuestFactory`, `ERC20Quest`, `ERC1155Quest`: Consider minimal clones

Consider deploying `ERC20Quest` and `ERC1155Quest` contracts as [ERC-1167 clones](https://eips.ethereum.org/EIPS/eip-1167) using OZ [`Clones`](https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones) or [`clones-with-immutable-args`](https://github.com/wighawag/clones-with-immutable-args). This is a big enough architectural change that you might not want to pursue it after an audit, but it could significantly decrease the cost of `createQuest` deployments. Minimal clone deployments are on the order of 100k gas rather than the 1MM currently used by `createQuest`.

### `QuestFactory`: Pack the `Quest` struct

The `totalParticipants` and `numberMinted` values in `Quest` can be packed in a single slot if you're willing to limit these to `type(uint128).max`. This is equal to 3.4 * 10^38 — much higher than the `totalParticipants` and `numberMinted` in any realistic scenario.

```solidity
    struct Quest {
        mapping(address => bool) addressMinted;
        address questAddress;
        uint totalParticipants;
        uint numberMinted;
    }
```

Suggestion:

```solidity
    struct Quest {
        mapping(address => bool) addressMinted;
        address questAddress;
        uint128 totalParticipants;
        uint128 numberMinted;
    }
```

### `Quest`: Remove `Counters.sol`

OZ `Counters.sol` doesn't do much any more, and you can safely omit it in `RabbitHoleReceipt`. Use a simple integer counter instead:

```solidity
    //using CountersUpgradeable for CountersUpgradeable.Counter;
    //CountersUpgradeable.Counter private _tokenIds;
    uint256 _tokenIds;
```

...and replace `increment()` with `++`:

```solidity
    /// @dev mint a receipt
    /// @param to_ the address to mint to
    /// @param questId_ the quest id
    function mint(address to_, string memory questId_) public onlyMinter {
        // _tokenIds.increment();
        // uint newTokenID = _tokenIds.current();
        uint newTokenID = ++_tokenIds;
        questIdForTokenId[newTokenID] = questId_;
        timestampForTokenId[newTokenID] = block.timestamp;
        _safeMint(to_, newTokenID);
    }
```

You can even use an `unchecked` block, since IDs are sequential and will never realistically overflow:

```solidity
    /// @dev mint a receipt
    /// @param to_ the address to mint to
    /// @param questId_ the quest id
    function mint(address to_, string memory questId_) public onlyMinter {
        uint newTokenID;
        unchecked { newTokenID = ++_tokenIds; }
        questIdForTokenId[newTokenID] = questId_;
        timestampForTokenId[newTokenID] = block.timestamp;
        _safeMint(to_, newTokenID);
    }
```

Impact: ~135 gas, plus 420 at deploy time.

```
·-----------------------------------------------|---------------------------|--------------|-----------------------------·
|             Solc version: 0.8.15              ·  Optimizer enabled: true  ·  Runs: 5000  ·  Block limit: 30000000 gas  │
················································|···························|··············|······························
|  Methods                                                                                                               │
··················|·····························|·············|·············|··············|···············|··············
|  Contract       ·  Method                     ·  Min        ·  Max        ·  Avg         ·  # calls      ·  eur (avg)  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  mintReceipt - unchecked    ·     276460  ·     287960  ·      282210  ·            4  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  mintReceipt - checked      ·     276546  ·     288046  ·      282296  ·            4  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  QuestFactory   ·  mintReceipt - original     ·     276595  ·     288095  ·      282345  ·            4  ·          -  │
··················|·····························|·············|·············|··············|···············|··············
|  Deployments                                  ·                                          ·  % of limit   ·             │
················································|·············|·············|··············|···············|··············
|  RabbitHoleReceipt                            ·          -  ·          -  ·     2776002  ·        9.3 %  ·          -  │
················································|·············|·············|··············|···············|··············
|  RabbitHoleReceipt - optimized                ·          -  ·          -  ·     2775582  ·        9.3 %  ·          -  │
·-----------------------------------------------|-------------|-------------|--------------|---------------|-------------·
```

### `QuestFactory`: Remove `questIdCount`

[`QuestFactory#createQuest`](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L101) increments a `questIdCount` variable for every new quest:

```solidity
            ++questIdCount;
```

However, this variable is not used on chain by any other contracts or calculations. Consider whether you need this data on chain, or if you can rely on the `QuestCreated` event to track this number off chain.

Impact: ~2900-20,000 gas (saves an `SSTORE`);

### `Quest`: Omit boolean checks

It's not necessary to perform an extra equality check for mappings that return a boolean. For example, since the `claimedList` mapping already stores a boolean, this check in [`isClaimed`](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L133) is unnecessary:

```solidity
    /// @notice Checks if a Receipt token id has been used to claim a reward
    /// @param tokenId_ The token id to check
    function isClaimed(uint256 tokenId_) public view returns (bool) {
        return claimedList[tokenId_] == true;
    }
```

Suggestion:

```solidity
    /// @notice Checks if a Receipt token id has been used to claim a reward
    /// @param tokenId_ The token id to check
    function isClaimed(uint256 tokenId_) public view returns (bool) {
        return claimedList[tokenId_];
    }
```

Additionally, since this function just wraps a mapping lookup, you can remove the function and inline `claimedList[tokenId_]` directly.

You can make similar change to [`QuestFactory.sol#L221`](https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/QuestFactory.sol#L221):

```solidity
        if (quests[questId_].addressMinted[msg.sender] == true) revert AddressAlreadyMinted();
```

Suggestion:

```solidity
        if (quests[questId_].addressMinted[msg.sender]) revert AddressAlreadyMinted();
```

This saves something like 3-13 gas, and should really probably be a style suggestion :)